// snake.js
// Simple Snake game that works with the provided HTML (canvas 400x400)

(() => {
  const canvas = document.getElementById('snakeCanvas');
  const ctx = canvas.getContext('2d');

  // Grid settings
  const canvasSize = 400;
  const tileCount = 20;
  const tileSize = canvasSize / tileCount;

  // Game state
  let snake = [{ x: 10, y: 10 }]; // starting with one segment
  let velocity = { x: 0, y: 0 };
  let nextVelocity = { x: 0, y: 0 };
  let food = { x: 15, y: 10 };
  let score = 0;
  let gameOver = false;
  let speed = 8; // game updates per second
  let lastFrameTime = 0;
  let moveInterval = 1000 / speed;

  // Prevent immediate reverse into self
  function setDirection(dx, dy) {
    // ignore if trying to reverse
    if (dx === -velocity.x && dy === -velocity.y) return;
    nextVelocity.x = dx;
    nextVelocity.y = dy;
  }

  // Place food in a location not occupied by the snake
  function placeFood() {
    const occupied = new Set(snake.map(s => `${s.x},${s.y}`));
    let x, y;
    do {
      x = Math.floor(Math.random() * tileCount);
      y = Math.floor(Math.random() * tileCount);
    } while (occupied.has(`${x},${y}`));
    food = { x, y };
  }

  function resetGame() {
    snake = [{ x: 10, y: 10 }];
    velocity = { x: 0, y: 0 };
    nextVelocity = { x: 0, y: 0 };
    placeFood();
    score = 0;
    gameOver = false;
  }

  function update() {
    // update direction
    velocity.x = nextVelocity.x;
    velocity.y = nextVelocity.y;

    if (velocity.x === 0 && velocity.y === 0) {
      // not moving yet
      return;
    }

    // compute new head
    const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

    // check wall collisions (game over)
    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
      gameOver = true;
      return;
    }

    // check self collision
    for (let i = 0; i < snake.length; i++) {
      if (snake[i].x === head.x && snake[i].y === head.y) {
        gameOver = true;
        return;
      }
    }

    // add head
    snake.unshift(head);

    // check food
    if (head.x === food.x && head.y === food.y) {
      score += 1;
      placeFood();
      // optionally increase speed every few points
      if (score % 5 === 0 && speed < 20) {
        speed += 1;
        moveInterval = 1000 / speed;
      }
    } else {
      // remove tail
      snake.pop();
    }
  }

  function drawGrid() {
    ctx.fillStyle = '#fafafa';
    ctx.fillRect(0, 0, canvasSize, canvasSize);
  }

  function draw() {
    drawGrid();

    // draw food
    ctx.fillStyle = '#e63946';
    ctx.fillRect(food.x * tileSize + 1, food.y * tileSize + 1, tileSize - 2, tileSize - 2);

    // draw snake
    for (let i = 0; i < snake.length; i++) {
      ctx.fillStyle = i === 0 ? '#2a9d8f'*
î€€
